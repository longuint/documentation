"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[6614],{5226:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>d,toc:()=>a});var o=t(5893),s=t(1151);const i={title:"Dependency Resolution"},r=void 0,d={id:"modding/guides/dependency-resolution",title:"Dependency Resolution",description:"This guide is for augmenting Flamework's dependency resolution, creating dependencies using dependency resolution and injecting custom values into the dependency resolution.",source:"@site/docs/modding/guides/dependency-resolution.md",sourceDirName:"modding/guides",slug:"/modding/guides/dependency-resolution",permalink:"/docs/modding/guides/dependency-resolution",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/modding/guides/dependency-resolution.md",tags:[],version:"current",frontMatter:{title:"Dependency Resolution"},sidebar:"flamework",previous:{title:"Singletons",permalink:"/docs/modding/guides/singletons"},next:{title:"User Macros",permalink:"/docs/modding/guides/user-macros"}},c={},a=[{value:"Creating custom objects",id:"creating-custom-objects",level:2},{value:"Injecting custom dependencies",id:"injecting-custom-dependencies",level:2},{value:"Augmenting singleton dependency resolution",id:"augmenting-singleton-dependency-resolution",level:2},{value:"DependencyResolutionOptions",id:"dependencyresolutionoptions",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"This guide is for augmenting Flamework's dependency resolution, creating dependencies using dependency resolution and injecting custom values into the dependency resolution."}),"\n",(0,o.jsxs)(n.p,{children:["Augmenting dependency resolution only affects constructor DI. The ",(0,o.jsx)(n.code,{children:"Dependency"})," macro is only usable for singletons."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-objects",children:"Creating custom objects"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to create custom objects, that aren't singletons, while allowing Flamework to resolve its dependencies then you can use the ",(0,o.jsx)(n.code,{children:"Modding.createDependency"})," API. This is the API that ",(0,o.jsx)(n.a,{href:"../../additional-modules/components/creating-a-component",children:"Flamework's component system"})," also uses."]}),"\n",(0,o.jsxs)(n.p,{children:["You can manipulate the dependency resolution by passing ",(0,o.jsx)(n.a,{href:"#dependencyresolutionoptions",children:"DependencyResolutionOptions"})," as the second parameter."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"@MyDecorator()\nclass MyDecoratorClass {\n\tconstructor(protected dependency: MyService) {\n\t\tprint(dependency);\n\t}\n}\n\nconst myDecoratorClass = Modding.createDependency(MyDecoratorClass);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"injecting-custom-dependencies",children:"Injecting custom dependencies"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes, you want to inject a value into Flamework's dependency resolution which can be used by any class. The modding API supports this using ",(0,o.jsx)(n.code,{children:"Modding.registerDependency<T>"})]}),"\n",(0,o.jsx)(n.p,{children:"This API takes a function which will pass the constructor being resolved and can return any value. The function is called whenever the specified ID is being resolved."}),"\n",(0,o.jsx)(n.p,{children:"This must be called prior to any attempts to resolve the specified ID, meaning prior to ignition. Preloading can also cause singletons to be resolved, though that is a bad practice."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="dependencies.ts"',children:'// This uses a marker type to prevent type interning.\nexport type Name = string & { _marker?: void };\nexport type Version = string & { _marker?: void };\nModding.registerDependency<Name>((ctor) => tostring(ctor));\nModding.registerDependency<Version>(() => "v1.5.2");\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="services/myService.ts"',children:'@Service()\nexport class MyService {\n\tconstructor(private name: Name, private version: Version) {\n\t\tassert(name === "MyService");\n\t\tassert(version === "v1.5.2");\n\t}\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"augmenting-singleton-dependency-resolution",children:"Augmenting singleton dependency resolution"}),"\n",(0,o.jsxs)(n.p,{children:["Singletons can be resolved at any point in time, so it is not safe to pass ",(0,o.jsx)(n.a,{href:"#dependencyresolutionoptions",children:"DependencyResolutionOptions"})," to ",(0,o.jsx)(n.code,{children:"Modding.resolveSingleton"})," like you can with ",(0,o.jsx)(n.code,{children:"Modding.createDependency"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you'd like to change the dependency resolution behavior, you can set the ",(0,o.jsx)(n.code,{children:"flamework:dependency_resolution"})," reflection metadata to a valid ",(0,o.jsx)(n.a,{href:"#dependencyresolutionoptions",children:"DependencyResolutionOptions"}),". This should be done in a decorator attached to your class as this ensures the singleton is not resolved prior to the metadata being attached."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export const Singleton = Modding.createDecorator("Class", (descriptor) => {\n\tReflect.defineMetadata(descriptor.object, "flamework:dependency_resolution", {\n\t\thandle: (id: string, index: number) => {\n\t\t\tprint(descriptor.object, "is resolving", id);\n\t\t}\n\t})\n})\n'})}),"\n",(0,o.jsx)(n.h2,{id:"dependencyresolutionoptions",children:"DependencyResolutionOptions"}),"\n",(0,o.jsx)(n.p,{children:"These are the options available to augment dependency resolution."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"interface DependencyResolutionOptions {\n\t/**\n\t * Fires whenever a dependency is attempting to be resolved.\n\t *\n\t * Return undefined to let Flamework resolve it.\n\t */\n\thandle?: (id: string, index: number) => unknown;\n\n\t/**\n\t * Fires whenever Flamework tries to resolve a primitive (e.g string)\n\t */\n\thandlePrimitive?: (id: string, index: number) => defined;\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>r});var o=t(7294);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);