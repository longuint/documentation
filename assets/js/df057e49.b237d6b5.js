"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[5522],{2335:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=a(5893),i=a(1151);const s={title:"User Macros"},r=void 0,o={id:"modding/guides/user-macros",title:"User Macros",description:"User macros are macros that can be defined by user code. They allow you to tap into metadata about type parameters and the call site.",source:"@site/docs/modding/guides/user-macros.md",sourceDirName:"modding/guides",slug:"/modding/guides/user-macros",permalink:"/docs/modding/guides/user-macros",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/modding/guides/user-macros.md",tags:[],version:"current",frontMatter:{title:"User Macros"},sidebar:"flamework",previous:{title:"Dependency Resolution",permalink:"/docs/modding/guides/dependency-resolution"}},d={},c=[{value:"Defining a user macro",id:"defining-a-user-macro",level:2},{value:"Nesting user macros",id:"nesting-user-macros",level:2},{value:"Advanced User Macros",id:"advanced-user-macros",level:2},{value:"Exposing your macro metadata",id:"exposing-your-macro-metadata",level:4},{value:"Objects / Tuples",id:"objects--tuples",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Mapped types",id:"mapped-types",level:3},{value:"Literals / Conditionals",id:"literals--conditionals",level:3},{value:"Utility types",id:"utility-types",level:2},{value:"Modding.Hash",id:"moddinghash",level:3},{value:"Modding.Obfuscate",id:"moddingobfuscate",level:3},{value:"Modding.TupleLabels",id:"moddingtuplelabels",level:3},{value:"Generic Metadata",id:"generic-metadata",level:2},{value:"Callsite Metadata",id:"callsite-metadata",level:2}];function l(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"User macros are macros that can be defined by user code. They allow you to tap into metadata about type parameters and the call site."}),"\n",(0,t.jsx)(n.h2,{id:"defining-a-user-macro",children:"Defining a user macro"}),"\n",(0,t.jsxs)(n.p,{children:["You define a macro simply by using the ",(0,t.jsx)(n.code,{children:"@metadata macro"})," tag and using one of Flamework's macro types as a parameter."]}),"\n",(0,t.jsx)(n.p,{children:"User macros can be defined on classes (constructors), methods, and plain functions."}),"\n",(0,t.jsx)(n.p,{children:"If you'd like users to be able to pass arguments to a macro argument, you are able to use a union.\nWhenever Flamework encounters a macro argument with a union, it will use the first macro type it encounters, or ignore the argument if a user has passed one."}),"\n",(0,t.jsxs)(n.p,{children:["Certain Flamework macros use this behavior to allow users to pass strings where Flamework would otherwise generate an ID, such as ",(0,t.jsx)(n.code,{children:'id?: string | Modding.Generic<T, "id">'}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'/** @metadata macro */\nfunction macro<T>(abc?: Modding.Generic<T, "id">, xyz?: Modding.CallerMany<"line" | "char">) {\n\tassert(abc && xyz);\n\n\tprint(abc, `${xyz.line}:${xyz.char}`);\n}\n\nmacro<MyInterface>();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"nesting-user-macros",children:"Nesting user macros"}),"\n",(0,t.jsx)(n.p,{children:"If you have a user macro that you'd like to call from within another user macro, you will need to include the macro's metadata in your signature, and pass it down."}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"Modding.GenericMany"})," and ",(0,t.jsx)(n.code,{children:"Modding.CallerMany"}),", you can include additional metadata and it can still be passed down.\nFor more complex macros, it is recommended to export your macro's metadata so that consumers can use your macro in their own."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'type BaseMacroMetadata<T> = Modding.GenericMany<T, "id" | "text">;\n\n/** @metadata macro */\nfunction baseMacro<T>(abc?: BaseMacroMetadata<T>) {}\n\n/** @metadata macro */\nfunction newMacro<T>(param: string, macro?: BaseMacroMetadata<T>) {\n\treturn baseMacro<T>(macro);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-user-macros",children:"Advanced User Macros"}),"\n",(0,t.jsxs)(n.p,{children:["Flamework supports a more advanced form of user macros allowing you to perform arbitrary conditions, mapped types and similar at compile time.\nThis is achieved using the ",(0,t.jsx)(n.code,{children:"Modding.Many"})," user macro API."]}),"\n",(0,t.jsx)(n.p,{children:"I've provided a list of syntax that you can use, but it is not exhaustive and Flamework can generate most types without any issues."}),"\n",(0,t.jsx)(n.h4,{id:"exposing-your-macro-metadata",children:"Exposing your macro metadata"}),"\n",(0,t.jsx)(n.p,{children:"In libraries, it is recommended that you specify macro metadata in an interface and expose it publicly.\nThis allows users to easily nest your macro inside of their own."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export interface DoSomethingMacro<T> {}\n\ndeclare function doSomething<T>(metadata?: Modding.Many<DoSomethingMacro<T>>);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"objects--tuples",children:"Objects / Tuples"}),"\n",(0,t.jsxs)(n.p,{children:["You can provide an object or a tuple to ",(0,t.jsx)(n.code,{children:"Modding.Many"})," and Flamework will generate an identical value when the function is called, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'declare function macro<T>(metadata?: Modding.Many<{ a: Modding.Generic<T, "id">, b: Modding.Caller<"uuid"> }>);\ndeclare function macro<T>(metadata?: Modding.Many<[Modding.Generic<T, "id">, Modding.Caller<"uuid">]>);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,t.jsxs)(n.p,{children:["Besides tuples, Flamework also supports generating arrays using de-unification.\nThis means that you are able to turn a union (e.g ",(0,t.jsx)(n.code,{children:"keyof T"}),") into an array of all constituents."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"declare function macro<T>(keysOfT?: Modding.Many<(keyof T)[]>);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mapped-types",children:"Mapped types"}),"\n",(0,t.jsx)(n.p,{children:"You are able to use mapped types to generate derivatives of an object which can be used to fetch additional information about members of a type."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'declare function macro<T>(guardsForEachMember?: Modding.Many<{ [k in keyof T]: Modding.Generic<T[k], "guard"> }>);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"literals--conditionals",children:"Literals / Conditionals"}),"\n",(0,t.jsx)(n.p,{children:"You can use conditional types to simulate if statements at compile-time.\nFlamework supports generating most literal values such as numbers, strings, booleans and undefined."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"declare function macro<T>(isString?: Modding.Many<T extends string ? true : false>);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"utility-types",children:"Utility types"}),"\n",(0,t.jsxs)(n.p,{children:["Flamework provides some additional utility types besides ",(0,t.jsx)(n.code,{children:"Modding.Generic"})," and ",(0,t.jsx)(n.code,{children:"Modding.Caller"})," which you can find here."]}),"\n",(0,t.jsx)(n.h3,{id:"moddinghash",children:"Modding.Hash"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Modding.Hash"})," allows you to generate a UUID based off a string (and an optional context.)"]}),"\n",(0,t.jsx)(n.h3,{id:"moddingobfuscate",children:"Modding.Obfuscate"}),"\n",(0,t.jsxs)(n.p,{children:["This behaves identically to ",(0,t.jsx)(n.code,{children:"Modding.Hash"})," except it is only enabled when Flamework obfuscation is enabled."]}),"\n",(0,t.jsx)(n.h3,{id:"moddingtuplelabels",children:"Modding.TupleLabels"}),"\n",(0,t.jsxs)(n.p,{children:["This retrieves the labels of a tuple and can be used in conjunction with ",(0,t.jsx)(n.code,{children:"Parameters<T>"})," to retrieve parameter names from a function type."]}),"\n",(0,t.jsx)(n.h2,{id:"generic-metadata",children:"Generic Metadata"}),"\n",(0,t.jsx)(n.p,{children:"Generic metadata exposes some built-in Flamework functions for types, such as guard generation and ID generation.\nThe input does not have to be a type parameter, and you can use it on any types, such as a mapped type."}),"\n",(0,t.jsxs)(n.p,{children:["This metadata can be accessed through ",(0,t.jsx)(n.code,{children:"Modding.Generic<T, M>"})," where ",(0,t.jsx)(n.code,{children:"T"})," is the target type, and ",(0,t.jsx)(n.code,{children:"M"})," is a string literal for the name of the metadata."]}),"\n",(0,t.jsxs)(n.p,{children:["Whilst ",(0,t.jsx)(n.code,{children:"Modding.Generic"})," can only retrieve one metadata at a time, ",(0,t.jsx)(n.code,{children:"Modding.GenericMany"})," can generate an object given a union of metadata, e.g ",(0,t.jsx)(n.code,{children:'"id" | "text"'}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface GenericMetadata<T> {\n\t/**\n\t * The ID of the type.\n\t */\n\tid: string;\n\n\t/**\n\t * A string equivalent of the type, such as the one displayed in your code editor.\n\t */\n\ttext: string;\n\n\t/**\n\t * A generated guard for the type.\n\t */\n\tguard: t.check<T>;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"callsite-metadata",children:"Callsite Metadata"}),"\n",(0,t.jsxs)(n.p,{children:["You can access callsite metadata by using ",(0,t.jsx)(n.code,{children:"Modding.Caller<M>"}),". Metadata about the source text ignores leading and trailing trivia."]}),"\n",(0,t.jsxs)(n.p,{children:["Whilst ",(0,t.jsx)(n.code,{children:"Modding.Caller"})," can only retrieve one metadata at a time, ",(0,t.jsx)(n.code,{children:"Modding.CallerMany"})," can generate an object given a union of metadata, e.g ",(0,t.jsx)(n.code,{children:'"line" | "character"'}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"\tinterface CallerMetadata {\n\t\t/**\n\t\t * The starting line of the expression.\n\t\t */\n\t\tline: number;\n\n\t\t/**\n\t\t * The char at the start of the expression relative to the starting line.\n\t\t */\n\t\tcharacter: number;\n\n\t\t/**\n\t\t * The width of the expression.\n\t\t * This includes the width of multiline statements.\n\t\t */\n\t\twidth: number;\n\n\t\t/**\n\t\t * A unique identifier that can be used to identify exact callsites.\n\t\t * This can be used for hooks.\n\t\t */\n\t\tuuid: string;\n\n\t\t/**\n\t\t * The source text for the expression.\n\t\t */\n\t\ttext: string;\n\t}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>o,a:()=>r});var t=a(7294);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);