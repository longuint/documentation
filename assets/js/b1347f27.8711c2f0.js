"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[9063],{5510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});var r=t(5893),i=t(1151);const o={title:"Creating a Singleton"},l=void 0,s={id:"guides/creating-a-singleton",title:"Creating a Singleton",description:"Flamework allows you to create Services (server) and Controllers (client). These are both singletons, meaning there will only ever be one instance of them. The only difference between the two is where they run. Services run on the server, while controllers run on the client. This means controllers have access to an OnRender lifecycle event that services do not.",source:"@site/docs/guides/creating-a-singleton.md",sourceDirName:"guides",slug:"/guides/creating-a-singleton",permalink:"/docs/guides/creating-a-singleton",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/guides/creating-a-singleton.md",tags:[],version:"current",frontMatter:{title:"Creating a Singleton"},sidebar:"flamework",previous:{title:"Configuration",permalink:"/docs/guides/configuration"},next:{title:"Dependencies",permalink:"/docs/guides/dependencies"}},c={},a=[{value:"Lifecycle Events",id:"lifecycle-events",level:2},{value:"Basic Service",id:"basic-service",level:2},{value:"Basic Controller",id:"basic-controller",level:2},{value:"Load Order",id:"load-order",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Flamework allows you to create Services (server) and Controllers (client). These are both singletons, meaning there will only ever be one instance of them. The only difference between the two is where they run. Services run on the server, while controllers run on the client. This means controllers have access to an OnRender lifecycle event that services do not."}),"\n",(0,r.jsx)(n.h2,{id:"lifecycle-events",children:"Lifecycle Events"}),"\n",(0,r.jsx)(n.p,{children:"Services, controllers and the like are able to implement lifecycle events. The functionality of these varies, but they all work the same way: implementing the proper interface."}),"\n",(0,r.jsxs)(n.p,{children:["Simply having a method with the same name as the lifecycle event isn't enough as all lifecycle events are opt-in, you have to explicitly declare your intent to subscribe to a specific lifecycle event. This is done by using ",(0,r.jsx)(n.code,{children:"implements LifecycleEvent"})," on your class declaration."]}),"\n",(0,r.jsx)(n.h2,{id:"basic-service",children:"Basic Service"}),"\n",(0,r.jsx)(n.p,{children:"This is a bare minimum example of a service with a lifecycle event connected."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { Service, OnTick } from "@flamework/core";\n\n@Service()\nexport class MyService implements OnTick {\n\tonTick(dt: number) {\n\t\tprint("My service is ticking", dt);\n\t}\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"basic-controller",children:"Basic Controller"}),"\n",(0,r.jsx)(n.p,{children:"This is a bare minimum example of a controller with a lifecycle event connected."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { Controller, OnRender } from "@flamework/core";\n\n@Controller()\nexport class MyController implements OnRender {\n\tonRender(dt: number) {\n\t\tprint("My controller is rendering", dt);\n\t}\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"load-order",children:"Load Order"}),"\n",(0,r.jsxs)(n.admonition,{title:"Dependency Injection",type:"info",children:[(0,r.jsx)(n.p,{children:"When you use dependency injection, Flamework will automatically determine the correct load order for you, so it is recommended to avoid setting this manually."}),(0,r.jsx)(n.p,{children:"This property will take priority over Flamework's automatic order but singletons with the same load order will still run in the automatic order."})]}),"\n",(0,r.jsxs)(n.p,{children:["You can use the ",(0,r.jsx)(n.code,{children:"loadOrder"})," configuration to override the order that singletons will call ",(0,r.jsx)(n.code,{children:"OnInit"})," and ",(0,r.jsx)(n.code,{children:"OnStart"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The default ",(0,r.jsx)(n.code,{children:"loadOrder"})," property defaults to ",(0,r.jsx)(n.code,{children:"1"})," and decreasing the ",(0,r.jsx)(n.code,{children:"loadOrder"})," causes the singleton to load earlier."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@Controller( {\n    loadOrder: 0 // Loads BEFORE all other controllers with default loadOrder\n})\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@Controller( {\n    loadOrder: 2 // Loads AFTER all other controllers with default loadOrder\n})\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>l});var r=t(7294);const i={},o=r.createContext(i);function l(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);