"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[1345],{4813:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>n,metadata:()=>l,toc:()=>c});var t=s(5893),i=s(1151);const n={title:"Utility Macros"},d=void 0,l={id:"guides/utility-macros",title:"Utility Macros",description:"\x3c!---",source:"@site/docs/guides/utility-macros.md",sourceDirName:"guides",slug:"/guides/utility-macros",permalink:"/docs/guides/utility-macros",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/guides/utility-macros.md",tags:[],version:"current",frontMatter:{title:"Utility Macros"},sidebar:"flamework",previous:{title:"Lifecycle Events",permalink:"/docs/guides/lifecycle-events"},next:{title:"Ignition!",permalink:"/docs/guides/ignition"}},a={},c=[{value:"<code>Flamework.addPaths</code>",id:"flameworkaddpaths",level:2},{value:"Description",id:"description",level:3},{value:"Parameters",id:"parameters",level:3},{value:"<code>...paths</code>",id:"paths",level:4},{value:"<code>Flamework.id</code>",id:"flameworkid",level:2},{value:"Description",id:"description-1",level:3},{value:"Returns",id:"returns",level:3},{value:"<code>Flamework.implements</code>",id:"flameworkimplements",level:2},{value:"Description",id:"description-2",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"<code>obj</code>",id:"obj",level:4},{value:"<code>Flamework.createGuard</code>",id:"flameworkcreateguard",level:2},{value:"Description",id:"description-3",level:3},{value:"Returns",id:"returns-1",level:3},{value:"<code>Flamework.hash</code>",id:"flameworkhash",level:2},{value:"Description",id:"description-4",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"<code>str</code>",id:"str",level:4},{value:"<code>context</code>",id:"context",level:4},{value:"Returns",id:"returns-2",level:3}];function o(e){const r={code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"flameworkaddpaths",children:(0,t.jsx)(r.code,{children:"Flamework.addPaths"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"function Flamework.addPaths(...paths: string[]): void\n"})}),"\n",(0,t.jsx)(r.h3,{id:"description",children:"Description"}),"\n",(0,t.jsx)(r.p,{children:"Preloads all modules under the paths passed into the function."}),"\n",(0,t.jsx)(r.h3,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(r.h4,{id:"paths",children:(0,t.jsx)(r.code,{children:"...paths"})}),"\n",(0,t.jsx)(r.p,{children:"A list of filesystem paths to preload."}),"\n",(0,t.jsxs)(r.p,{children:["The paths are relative to the project directory however, if prefixed with ",(0,t.jsx)(r.code,{children:"./"}),", you can make the path relative to the file it's in."]}),"\n",(0,t.jsxs)(r.p,{children:["Globs are also supported (e.g ",(0,t.jsx)(r.code,{children:"src/folder/*/client"})," or ",(0,t.jsx)(r.code,{children:"src/folder/**/client"}),") however, when using globs, you can only preload entire folders and relative paths are disabled."]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"flameworkid",children:(0,t.jsx)(r.code,{children:"Flamework.id"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"function Flamework.id<T>(): string;\n"})}),"\n",(0,t.jsx)(r.h3,{id:"description-1",children:"Description"}),"\n",(0,t.jsxs)(r.p,{children:["Fetches the unique identifier Flamework uses for the type parameter ",(0,t.jsx)(r.code,{children:"T"}),". These IDs are used to retrieve classes, specify metadata, etc."]}),"\n",(0,t.jsx)(r.h3,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(r.p,{children:["The generated ID for the type parameter ",(0,t.jsx)(r.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"flameworkimplements",children:(0,t.jsx)(r.code,{children:"Flamework.implements"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"function Flamework.implements<T>(obj: unknown): obj is T;\n"})}),"\n",(0,t.jsx)(r.h3,{id:"description-2",children:"Description"}),"\n",(0,t.jsxs)(r.p,{children:["Checks if the passed in object implements the type parameter ",(0,t.jsx)(r.code,{children:"T"}),". This checks at runtime using metadata attached by Flamework, which means it only works on Flamework classes."]}),"\n",(0,t.jsx)(r.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,t.jsx)(r.h4,{id:"obj",children:(0,t.jsx)(r.code,{children:"obj"})}),"\n",(0,t.jsx)(r.p,{children:"The object to check."}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"flameworkcreateguard",children:(0,t.jsx)(r.code,{children:"Flamework.createGuard"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"function Flamework.createGuard<T>(): t.check<T>;\n"})}),"\n",(0,t.jsx)(r.h3,{id:"description-3",children:"Description"}),"\n",(0,t.jsxs)(r.p,{children:["Creates a guard for the type parameter ",(0,t.jsx)(r.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"Guards are generated in a way that mimicks how the type can be used in TypeScript which means generics will resolve to their constraints, (unsimplified) conditionals will resolve to a union between both true/false types, etc."}),"\n",(0,t.jsx)(r.h3,{id:"returns-1",children:"Returns"}),"\n",(0,t.jsxs)(r.p,{children:["The generated guard for type parameter ",(0,t.jsx)(r.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"flameworkhash",children:(0,t.jsx)(r.code,{children:"Flamework.hash"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:'function Flamework.hash(str: string, context: string = "@"): string;\n'})}),"\n",(0,t.jsx)(r.h3,{id:"description-4",children:"Description"}),"\n",(0,t.jsx)(r.p,{children:"Hashes a string literal. Hashes are randomly generated but only regenerated when compilation is restarted which guarantees they will be the same value everywhere they are used."}),"\n",(0,t.jsx)(r.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,t.jsx)(r.h4,{id:"str",children:(0,t.jsx)(r.code,{children:"str"})}),"\n",(0,t.jsx)(r.p,{children:"The string to hash."}),"\n",(0,t.jsx)(r.h4,{id:"context",children:(0,t.jsx)(r.code,{children:"context"})}),"\n",(0,t.jsxs)(r.p,{children:["The context which this string should be hashed. Two identical strings compiled under different contexts will result in different hashes. This is used to separate hashes used for different things (e.g networking uses the ",(0,t.jsx)(r.code,{children:"remotes"})," context)."]}),"\n",(0,t.jsx)(r.h3,{id:"returns-2",children:"Returns"}),"\n",(0,t.jsx)(r.p,{children:"The hashed string."})]})}function h(e={}){const{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},1151:(e,r,s)=>{s.d(r,{Z:()=>l,a:()=>d});var t=s(7294);const i={},n=t.createContext(i);function d(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);