"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[9377],{1622:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var r=t(5893),i=t(1151);const o={title:"Remote Functions"},s=void 0,a={id:"additional-modules/networking/remote-functions",title:"Remote Functions",description:"RemoteFunctions are for two way communicates between the server and client. This means the sender is able to receive a response from the receiver.  Flamework's RemoteFunctions implementation use promises which allow you to avoid any dangerous yields, errors, etc. All requests have a timeout of 10 seconds.",source:"@site/docs/additional-modules/networking/remote-functions.md",sourceDirName:"additional-modules/networking",slug:"/additional-modules/networking/remote-functions",permalink:"/docs/additional-modules/networking/remote-functions",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/docs/additional-modules/networking/remote-functions.md",tags:[],version:"current",frontMatter:{title:"Remote Functions"},sidebar:"flamework",previous:{title:"Remote Events",permalink:"/docs/additional-modules/networking/remote-events"},next:{title:"Configuration",permalink:"/docs/additional-modules/networking/configuration"}},c={},l=[{value:"Creation",id:"creation",level:2},{value:"Using Functions",id:"using-functions",level:2},{value:"Invoking Functions",id:"invoking-functions",level:3},{value:"Handling Functions",id:"handling-functions",level:3},{value:"Errors",id:"errors",level:2},{value:"Handling errors",id:"handling-errors",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"RemoteFunctions are for two way communicates between the server and client. This means the sender is able to receive a response from the receiver.  Flamework's RemoteFunctions implementation use promises which allow you to avoid any dangerous yields, errors, etc. All requests have a timeout of 10 seconds."}),"\n",(0,r.jsxs)(n.p,{children:["Whilst it is not recommended, Flamework does support ",(0,r.jsx)(n.code,{children:"ServerToClient"})," remote functions. Flamework avoids common pitfalls by implementing timeouts and cancellation (such as a player leaving) using promises."]}),"\n",(0,r.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,r.jsxs)(n.p,{children:["You can use the ",(0,r.jsx)(n.code,{children:"Networking.createFunction"})," macro to create your network handler. This will contain all your events for both server and client and you can also configure your ",(0,r.jsx)(n.a,{href:"./middleware",children:"middleware"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { Networking } from "@flamework/networking";\n\ninterface ClientToServerFunctions {\n\tfunction(param1: string): number;\n}\n\ninterface ServerToClientFunctions {\n\tfunction(param1: string): number;\n}\n\n// Returns an object containing a `server` and `client` field.\nexport const GlobalFunctions = Networking.createFunction<ClientToServerFunctions, ServerToClientFunctions>();\n\n// It is recommended that you create these in separate server/client files,\n// which will avoid exposing server configuration (including type guards) to the client.\nexport const ServerFunctions = GlobalFunctions.createServer({ /* server config */ });\nexport const ClientFunctions = GlobalFunctions.createClient({ /* client config */ });\n'})}),"\n",(0,r.jsx)(n.h2,{id:"using-functions",children:"Using Functions"}),"\n",(0,r.jsxs)(n.p,{children:["Once you've declared all your functions, it's time to use them. You can access your functions simply by indexing the ",(0,r.jsx)(n.a,{href:"./introduction#re-exporting",children:"Functions"})," object."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"player?"})," parameter in the following examples means that the parameter only exists on the server, and is absent on the client."]}),"\n",(0,r.jsx)(n.h3,{id:"invoking-functions",children:"Invoking Functions"}),"\n",(0,r.jsx)(n.p,{children:"Invoke a request and wait for a response."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// Invoke a function\nFunctions.function.invoke(player?, "my parameter!").then((value) => ...);\n\n// Shorthand syntax, equivalent to Functions.\nFunctions.function(player?, "my parameter!").then((value) => ...);\n\n// Predict, simulates a request being sent\nFunctions.function.predict(player?, "my parameter!").then((value) => ...);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"handling-functions",children:"Handling Functions"}),"\n",(0,r.jsxs)(n.p,{children:["You can only connect one handler to each function. Calling ",(0,r.jsx)(n.code,{children:"setCallback"})," more than once will override the existing handler but will result in a warning being outputted."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// With a normal function\nFunctions.function.setCallback((player?, param1) => {\n\tprint("This is", param1);\n\treturn math.random(1, 100);\n})\n\n// With an async function\nFunctions.function.setCallback(async (player?, param1) => {\n\tprint("This is", param1);\n\treturn await myAsyncNumberGenerator(1, 100);\n})\n'})}),"\n",(0,r.jsx)(n.h2,{id:"errors",children:"Errors"}),"\n",(0,r.jsxs)(n.p,{children:["Flamework's networking exposes a ",(0,r.jsx)(n.code,{children:"NetworkingFunctionError"})," enum which is used whenever a RemoteFunction request is rejected."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Timeout"}),(0,r.jsx)(n.td,{children:"The request surpassed the timeout length."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Cancelled"}),(0,r.jsx)(n.td,{children:"The request was cancelled by the receiver."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"BadRequest"}),(0,r.jsx)(n.td,{children:"The request was rejected by the receiver due to invalid arguments."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"InvalidResult"}),(0,r.jsx)(n.td,{children:"The request was processed by the receiver, but an invalid result was returned."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Unprocessed"}),(0,r.jsx)(n.td,{children:"The request was not processed by the receiver."})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"handling-errors",children:"Handling errors"}),"\n",(0,r.jsxs)(n.p,{children:["Flamework's RemoteFunctions return promises which allows you to handle them the same as any other promise.\nFlamework always passes a ",(0,r.jsx)(n.code,{children:"NetworkingFunctionError"})," as the rejection value, which tells you the reason the request failed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'Events.function.invoke()\n\t.then((value) => print("I successfully got", value))\n\t.catch((reason) => {\n\t\tif (reason === NetworkingFunctionError.Timeout) {\n\t\t\twarn("My request timed out!");\n\t\t} else {\n\t\t\twarn("A different error occurred:", reason);\n\t\t}\n\t})\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var r=t(7294);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);