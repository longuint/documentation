"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[5979],{3056:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var a=n(5893),i=n(1151);const s={title:"Attributes"},r=void 0,o={id:"additional-modules/components/attributes",title:"Attributes",description:"Components support attributes out of the box! It'll even generate type guards for each attribute, automatically.",source:"@site/docs/additional-modules/components/attributes.md",sourceDirName:"additional-modules/components",slug:"/additional-modules/components/attributes",permalink:"/docs/additional-modules/components/attributes",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/additional-modules/components/attributes.md",tags:[],version:"current",frontMatter:{title:"Attributes"},sidebar:"flamework",previous:{title:"Scripting API",permalink:"/docs/additional-modules/components/scripting-api"},next:{title:"Inheritance",permalink:"/docs/additional-modules/components/inheritance"}},l={},u=[{value:"Adding attributes to a component",id:"adding-attributes-to-a-component",level:2},{value:"Default attributes",id:"default-attributes",level:2},{value:"Refined type guards",id:"refined-type-guards",level:2},{value:"Mutable attributes",id:"mutable-attributes",level:2},{value:"Attribute Changes",id:"attribute-changes",level:2},{value:"Disabling automatic attribute updates",id:"disabling-automatic-attribute-updates",level:2}];function d(t){const e={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:"Components support attributes out of the box! It'll even generate type guards for each attribute, automatically."}),"\n",(0,a.jsx)(e.h2,{id:"adding-attributes-to-a-component",children:"Adding attributes to a component"}),"\n",(0,a.jsx)(e.p,{children:"Adding attributes to a component is very straightforward. Define an interface, pass it into BaseComponent, and voila!"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"interface Attributes {\n\tprop1: string,\n\tprop2: number,\n}\n\n@Component()\nexport class MyComponent extends BaseComponent<Attributes> implements OnStart {\n\tonStart() {\n\t\tprint(this.attributes.prop1, this.attributes.prop2);\n\t}\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"default-attributes",children:"Default attributes"}),"\n",(0,a.jsx)(e.p,{children:"By default, Flamework will throw an error when a component is added to an instance which does not pass the attribute guards.\nIf you define default attributes, Flamework will simply ignore incorrect (or missing) attributes and replace them with the default."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'@Component({\n\tdefaults: {\n\t\tprop1: "My default string!",\n\t\tprop2: 02496\n\t}\n})\n'})}),"\n",(0,a.jsx)(e.h2,{id:"refined-type-guards",children:"Refined type guards"}),"\n",(0,a.jsx)(e.p,{children:"The TypeScript type system can't always perfectly reflect the input you expect, which also means Flamework's type guard generation can't either.\nIf there's an attribute that requires a guard that can't be generated from the type, e.g a constrained number, you can manually specify your own guards.\nFlamework will still use the generated guard for any prop that isn't specified."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"@Component({\n\tattributes: {\n\t\tprop2: t.numberConstrained(1, 5)\n\t}\n})\n"})}),"\n",(0,a.jsx)(e.h2,{id:"mutable-attributes",children:"Mutable attributes"}),"\n",(0,a.jsx)(e.p,{children:"The attributes object on components is mutable, so you can change the value and it'll change in both the component's copy and on the instance."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'export class MyComponent extends BaseComponent<Attributes> implements OnStart {\n\tonStart() {\n\t\tprint(this.attributes.prop2++);\n\n\t\tprint(this.attributes.prop1);\n\t\tthis.attributes.prop1 += "suffix!";\n\t\tprint(this.attributes.prop1, this.instance.GetAttribute("prop1"));\n\t}\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"attribute-changes",children:"Attribute Changes"}),"\n",(0,a.jsx)(e.p,{children:"If refreshAttributes is enabled, you can listen for changes to attributes on the component's instance.\nFlamework will only fire the handlers if the new attribute's value is valid."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'export class MyComponent extends BaseComponent<Attributes> implements OnStart {\n\tonStart() {\n\t\tthis.onAttributeChanged("prop1", (value, oldValue) => {\n\t\t\tprint("Value is now: ", value);\n\t\t\tprint("Value was: ", oldValue);\n\t\t})\n\t}\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"disabling-automatic-attribute-updates",children:"Disabling automatic attribute updates"}),"\n",(0,a.jsx)(e.p,{children:"By default, Flamework will listen for attribute changes. You can turn this behavior off, however this will also disable onAttributeChanged handlers."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"@Component({\n\trefreshAttributes: false\n})\n"})})]})}function c(t={}){const{wrapper:e}={...(0,i.a)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(d,{...t})}):d(t)}},1151:(t,e,n)=>{n.d(e,{Z:()=>o,a:()=>r});var a=n(7294);const i={},s=a.createContext(i);function r(t){const e=a.useContext(s);return a.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function o(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),a.createElement(s.Provider,{value:e},t.children)}}}]);