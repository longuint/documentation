"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[1011],{6895:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=t(5893),s=t(1151);const a={title:"Creating a Component"},c=void 0,i={id:"additional-modules/components/creating-a-component",title:"Creating a Component",description:"A component is a class which is attached to a Roblox instance.",source:"@site/docs/additional-modules/components/creating-a-component.md",sourceDirName:"additional-modules/components",slug:"/additional-modules/components/creating-a-component",permalink:"/docs/additional-modules/components/creating-a-component",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/additional-modules/components/creating-a-component.md",tags:[],version:"current",frontMatter:{title:"Creating a Component"},sidebar:"flamework",previous:{title:"Global Handlers",permalink:"/docs/additional-modules/networking/global-handlers"},next:{title:"Scripting API",permalink:"/docs/additional-modules/components/scripting-api"}},r={},l=[{value:"Declaring the component",id:"declaring-the-component",level:2},{value:"Using the component",id:"using-the-component",level:2},{value:"Instance type",id:"instance-type",level:2},{value:"Component Dependencies",id:"component-dependencies",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"A component is a class which is attached to a Roblox instance.\nIt's able to access lifecycle events, as well as use constructor DI.\nA component is useful for representing objects inside of your game world, for example a door, a vehicle or a weapon."}),"\n",(0,o.jsxs)(n.p,{children:["Refer to ",(0,o.jsx)(n.a,{href:"/docs/guides/lifecycle-events",children:"Lifecycle Events"})," for which lifecycle events work on components."]}),"\n",(0,o.jsx)(n.h2,{id:"declaring-the-component",children:"Declaring the component"}),"\n",(0,o.jsx)(n.p,{children:"Declaring a component is very similar to the way you declare singletons, except you must extend the base component class: BaseComponent."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { OnStart } from "@flamework/core";\nimport { Component, BaseComponent } from "@flamework/components";\n\n@Component()\nexport class MyComponent extends BaseComponent implements OnStart {\n\tconstructor(private myDependency: MyDependency) {\n\t\tsuper();\n\t}\n\n\tonStart() {\n\t\tprint(`Wow! I\'m attached to ${this.instance.GetFullName()}`);\n\t}\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"using-the-component",children:"Using the component"}),"\n",(0,o.jsxs)(n.p,{children:["There are two ways you can attach an instance to a component, the ",(0,o.jsx)(n.a,{href:"/docs/additional-modules/components/scripting-api",children:"Scripting API"})," and a CollectionService tag. If you'd like to use the Scripting API, refer to the linked documentation."]}),"\n",(0,o.jsx)(n.p,{children:"If you'd like to use a CollectionService tag, it's very simple! Just specify it in your Component's config."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'@Component({\n\ttag: "my-cs-tag",\n})\n'})}),"\n",(0,o.jsx)(n.h2,{id:"instance-type",children:"Instance type"}),"\n",(0,o.jsxs)(n.p,{children:["You likely only want your component to be instantiated on the correct objects.\nThe first type parameter of BaseComponent is for ",(0,o.jsx)(n.a,{href:"/docs/additional-modules/components/attributes",children:"attributes"}),", however the second allows you to specify a custom Instance type. Flamework will automatically generate a type guard for it, and prevent attaching your component to invalid objects."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"interface MyComponentInstance extends Model {\n\thinge: BasePart & {\n\t\tconstraint: HingeConstraint\n\t},\n}\n\nexport class MyComponent extends BaseComponent<{}, MyComponentInstance> implements OnStart {\n\tonStart() {\n\t\tprint(this.instance.hinge.constraint);\n\t}\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"component-dependencies",children:"Component Dependencies"}),"\n",(0,o.jsx)(n.p,{children:"Flamework supports inter-component dependencies using dependency injection.\nThis only works for components attached to the same instance."}),"\n",(0,o.jsx)(n.p,{children:"Flamework will wait until any component dependencies have been added before creating your component."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class MyComponent extends BaseComponent {}\n\n// MyOtherComponent will not be created until MyComponent is\nclass MyOtherComponent extends BaseComponent {\n\tconstructor(private myComponent: MyComponent) {}\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>c});var o=t(7294);const s={},a=o.createContext(s);function c(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);