"use strict";(self.webpackChunkflamework=self.webpackChunkflamework||[]).push([[9175],{421:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var r=o(5893),n=o(1151);const a={title:"Decorators"},s=void 0,c={id:"modding/guides/decorators",title:"Decorators",description:"This guide is for creating a custom decorator.",source:"@site/docs/modding/guides/decorators.md",sourceDirName:"modding/guides",slug:"/modding/guides/decorators",permalink:"/docs/modding/guides/decorators",draft:!1,unlisted:!1,editUrl:"https://github.com/rbxts-flamework/documentation/tree/master/docs/modding/guides/decorators.md",tags:[],version:"current",frontMatter:{title:"Decorators"},sidebar:"flamework",previous:{title:"Lifecycle Events",permalink:"/docs/modding/guides/lifecycle-events"},next:{title:"Singletons",permalink:"/docs/modding/guides/singletons"}},i={},d=[{value:"Defining the decorator",id:"defining-the-decorator",level:2},{value:"Implementing the custom decorators",id:"implementing-the-custom-decorators",level:2}];function l(t){const e={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,n.a)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"This guide is for creating a custom decorator."}),"\n",(0,r.jsx)(e.p,{children:"It is recommended to use native roblox-ts decorators unless you need Flamework behavior, such as access to the modding decorator APIs."}),"\n",(0,r.jsx)(e.h2,{id:"defining-the-decorator",children:"Defining the decorator"}),"\n",(0,r.jsx)(e.p,{children:"Flamework has two kinds of decorators, meta decorators and normal decorators."}),"\n",(0,r.jsx)(e.p,{children:"All Flamework decorators add the metadata necessary for the modding API, however, normal decorators also allow you to run a custom function afterwards. This function is passed information about where it was applied as well as the arguments passed into it."}),"\n",(0,r.jsxs)(e.p,{children:["You are also able to define metadata which will be generated when a class uses your decorator as shown in ",(0,r.jsx)(e.a,{href:"../metadata#how-do-i-request-metadata",children:"the metadata docs"}),"."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'// Property Decorators\nexport const FieldDecorator = Modding.createMetaDecorator<[string]>("Property");\nexport const FieldDecorator = Modding.createDecorator<[string]>("Property", (descriptor, [name]) => {\n\tprint("Decorated field", descriptor.isStatic, tostring(descriptor.object) + "." + descriptor.property);\n\tprint("Passed in name:", name);\n});\n\n// Method Decorators\nexport const MethodDecorator = Modding.createMetaDecorator<[string]>("Method");\nexport const MethodDecorator = Modding.createDecorator<[string]>("Method", (descriptor, [name]) => {\n\tprint("Decorated method", descriptor.isStatic, tostring(descriptor.object) + "." + descriptor.property + "()");\n\tprint("Passed in name:", name);\n});\n\n// Class Decorators\nexport const NameDecorator = Modding.createMetaDecorator<[string]>("Class");\nexport const NameDecorator = Modding.createDecorator<[string]>("Class", (descriptor, [name]) => {\n\tprint("Decorated object", descriptor.object);\n\tprint("Passed in name:", name);\n});\n\n@NameDecorator("Peter")\nclass A {\n\t@FieldDecorator("John")\n\tpublic abc = 1;\n\n\t@FieldDecorator("Andrew")\n\t@MethodDecorator("Andrew")\n\tpublic method() {}\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"implementing-the-custom-decorators",children:"Implementing the custom decorators"}),"\n",(0,r.jsx)(e.p,{children:"After defining the decorator and any metadata you want it to use, you can use the listeners API to implement it. It's recommended that you implement decorators in a service/controller so that they only occur after ignition."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'@Service()\nexport class MyDecoratorService implements OnStart {\n\tonStart() {\n\t\t// Retrieve all constructors that are using the NameDecorator\n\t\t// You can do whatever you wish with the constructor from here\n\t\t// e.g construct an instance via Flamework\'s dependency resolution\n\t\tconst constructors = Modding.getDecorators<typeof NameDecorator>();\n\t\tfor (const { object, arguments: args } of constructors) {\n\t\t\tprint(object, "is named", args[0]);\n\t\t}\n\n\t\t// Listen for new listeners that are using NameDecorator\n\t\tModding.onListenerAdded<typeof NameDecorator>((object) => {\n\t\t\t// Retrieves the arguments from the decorator\n\t\t\tconst decorator = Modding.getDecorator<typeof NameDecorator>(object);\n\t\t\tif (decorator) {\n\t\t\t\tconst [name] = decorator.arguments;\n\t\t\t\tprint(object, "is the child of", name);\n\t\t\t}\n\n\t\t\t// Retrieves all the FieldDecorators\n\t\t\tfor (const [prop, decorator] of Modding.getPropertyDecorators<typeof FieldDecorator>(object)) {\n\t\t\t\tconst [name] = decorator.arguments;\n\t\t\t\tprint(object, "has prop", prop, "with name", name);\n\t\t\t}\n\t\t});\n\t}\n}\n'})})]})}function m(t={}){const{wrapper:e}={...(0,n.a)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}},1151:(t,e,o)=>{o.d(e,{Z:()=>c,a:()=>s});var r=o(7294);const n={},a=r.createContext(n);function s(t){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:s(t.components),r.createElement(a.Provider,{value:e},t.children)}}}]);